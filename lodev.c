#include <stdio.h>
#include <math.h>

#define mapWidth 24
#define mapHeight 24
#define screenWidth 640
#define screenHeight 480

int worldMap[mapWidth][mapHeight]=
{
  {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,2,2,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,3,0,0,0,3,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,2,0,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,0,0,0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};

int main(void)
{
    
    void    *mlx_ptr;
    void    *win_ptr;
    void    *img_ptr;
    char    *img_addr;

    /* Establish the connection between the X server and X client */
    mlx_ptr = mlx_init();
    if (mlx_ptr == NULL)
        return (-1);
    
    /* Create the window */
    win_ptr = mlx_new_window(mlx_ptr, screenWidth, screenHeight, "lodev");
    if (win_ptr == NULL)
        return (-1);

    /* Create an empty image */ 
    img_ptr = mlx_new_image(mlx_ptr, screenWidth, screenHeight);
    if (img_ptr == NULL)
        return (-1);

    /* Get the address of the image */
    int bits_per_pixel;
    int line_size;
    int endian;
    img_addr = mlx_get_data_addr(img_ptr, &bits_per_pixel, &line_size, &endian);

    /* mlx_loop is needed to listen for events */
    mlx_loop(mlx_ptr);

    /* Initialize player position */
    double posX = 22;
    double posY = 12;

    /* Initialize direction vector */
    double dirX = -1;
    double dirY = 0;

    /* Initialize camera plane */
    double planeX = 0;
    double planeY = 0.66;

    /* Loop over the width of the screen */
    for (int x = 0; x < screenWidth; x++)
    {
        /* Calculate ray position */
        double cameraX = 2 * x / (double)screenWidth - 1;
        double rayDirX = dirX + planeX * cameraX;
        double rayDirY = dirY + planeY * cameraX;

        /* Coordinates of where we are */
        int mapX = (int)posX;
        int mapY = (int)posY;

        /* Distance from current position to next x and y side */
        double sideDistX;
        double sideDistY;

        /* Length of ray from one x or y-side to next one */
        double deltaDistX = fabs(1 / rayDirX);
        double deltaDistY = fabs(1 / rayDirY);

        /* Later used to calculate ray length */
        double perpWallDist;

        /* What direction to step in x or y direction (either +1 or -1) */
        int stepX;
        int stepY;

        /* Was there a wall hit? */
        int hit = 0;
        
        /* Which side did we hit the wall? (horizontal or vertical side) */
        int side;

        /* Calculate the step and initial sideDist */
        if (rayDirX < 0)
        {    
            stepX = -1;
            sideDistX = (posX - mapX) * deltaDistX;
        }
        else
        {
            stepX = 1;
            sideDistX = (mapX + 1.0 - posX) * deltaDistX;
        }
        if (rayDirY < 0)
        {    
            stepY = -1;
            sideDistY = (posY - mapY) * deltaDistY;
        }
        else
        {
            stepY = 1;
            sideDistY = (mapY + 1.0 - posY) * deltaDistY;
        }

        /* Perfrom DDA algorithm */
        while (hit == 0)
        {
            if (sideDistX < sideDistY)
            {
                sideDistX += deltaDistX;
                mapX += stepX;
                side = 0;
            }
            else
            {
                sideDistY += deltaDistY;
                mapY += stepY;
                side = 1;
            }

            /*  */
            
        }

    }


    return (0);
}